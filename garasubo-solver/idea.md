## コアアイデア：固定サフィックス指紋（Fixed‑tail Fingerprinting）

* ある状態（部屋）から**同じ固定サフィックス** $R$（例：長さ 16 のドア列）を辿ったときに得られる**2bit ラベル列**を、その状態の**指紋**と見做します。
  指紋長が 17（= R 長 + 1）あれば、4^17 以上のパターンがあり、n ≤ 30 なら**ほぼ一意**になります（重複確率は $\binom{30}{2}/4^{17} \ll 10^{-6}$ 程度）。
* すると、**指紋が一致する経路の到達点は同一の部屋**だと高速に同定できます（ハッシュで十分）。

これを使って、**状態集合（部屋）と遷移（各ドアの行き先）を非適応に復元**します。

---

## 1 回の `/explore` に詰め込む計画（経路群の組み立て）

記号：

* Σ = {0,1,2,3,4,5}（ドア番号）
* $R$：固定サフィックス（例：乱数で 16 ステップ）
* `plan(s)` は「プレフィックス `s` に続けて R を付けたもの」、すなわち **`s ∘ R`**。

### (A) プレフィックス集合 S（状態カバレッジ）

* 目的：**全ての部屋に少なくとも 1 回は到達**する。
* 取り方（実戦向け）：

    * $|S|$ は **約 $2 \, n \log n$** を目安（被覆確率 99% 近辺）。n=30 なら 240 前後。
      近似的には「M 本のランダム経路で全30状態をカバーする確率 $ \approx 1 - 30 e^{-M/30}$」なので、M≈240で 99% 程度。
    * 具体例：\*\*長さ 3 の全列挙（216 本）\*\*に、**30 本ほどのランダム列**を足す（合計 ≈ 246 本）。長さ 3 の列挙だけでも、ランダム生成の迷宮ならほぼ全到達（混合が速い）ですが、保険でランダムを追加。
    * すべての `s ∈ S` について **`plan(s)`** を投げ、**到達状態の指紋**を集める。

### (B) 1 ステップ先の遷移も取る

* 各 `s ∈ S` と各ドア `a ∈ Σ` に対して **`plan(s ∘ a)`** も投げます。
  これで、`s` から `a` を出た先の部屋の指紋が取れ、\*\*「部屋 × ドア → 次の部屋」\*\*が決まります。

> 以上 (A)+(B) のみで、\*\*各部屋の 6 本の出先（有向遷移）**は同定できます。
> **合計プラン数**は概ね $|S| × (1 + |Σ|)$（+ 1 で開始のみ `plan(ε)` を足しても良い）。
> 例：n=30, $|S|=246$ ⇒ **1,722 本**。各プラン長は最大でも (|s| + |R| ≤ 3 + 16 = 19 \ll 18n(=540)** なので余裕。

---

## 後処理（探索結果 → 地図）

1. **指紋集計**

    * すべての結果 `plan(s)` の観測列（長さ |R|+1）を**ハッシュ**し、`fingerprint → room_id` を割り当て。
    * 同じ指紋は**同じ部屋**。部屋ラベル（2bit 値）は観測列の先頭要素で決まります。
    * 期待される部屋数 n が揃うことを確認（揃わなければ S をもう少し厚くする設計に）。
2. **遷移の復元**

    * 各 `s ∈ S` に対し、`room_id(s)` を取り、各 `a ∈ Σ` について `room_id(s ∘ a)` を取る。
      これで **δ(room, a) = next\_room** が埋まります。
3. **無向ペアリング（to側のドア番号 b）**

    * 仕様上は接続を「(from: room i, door a) ↔ (to: room j, door b)」で提出しますが、**観測で入口ドア番号 b は取得できません**（記録は部屋ラベルのみ）。
    * ただし「**提出地図は任意の経路計画に対して観測が一致すれば同値**」という採点なので、**i→j となる a の集合**と **j→i となる b の集合**の間で**任意の全単射でペア**にしても観測は区別不能です（a→j の事実と、j の b が i へ戻す事実さえ満たせば、その **どの b を「入ったときの入口」と見做しても観測列は同じ**）。
    * 実装は単純に：各 (i,a) について j=δ(i,a) を取り、j 側の未使用な {b | δ(j,b)=i} から小さい順に 1 つ割当て、**双方向多重辺**にも対応できるよう管理します。
    * これで **connections** を全て埋められます。
      （「同値性」の定義は“どんな経路でも区別できない”であり、入口ドア番号それ自体は観測されないため。）

---

## なぜ速いか／なぜ 1 回で済むか

* **/explore は 1 回**だけ。すべてのプランを**一括送信**します（バッチ送信は推奨され、/explore 呼び出し回数に1ポイントのペナルティが入るだけ）。
* 後処理は

    * 指紋の**ハッシュマップ**構築（O(総プラン数 × |R|)）、
    * それを使った**辞書引き**で遷移表を埋めるだけ。
      SAT のような巨大な組合せ探索が不要で、**実装が非常に軽い**です。

---

## 推奨パラメータ（問題サイズ別の目安）

* $R$ の長さ：**16**（衝突確率十分小さい。保守的なら 20）。
* S の作り方：

    * **長さ 3 を全列挙（216 本）** + **ランダム 30 本**（合計 ≈ 246 本）。

        * 期待カバー率 ≈ 99%（n=30）。n が小さいセット（6,12,18,24）ではさらに余裕。
* プラン総数：$|S| × 7 ≈ 1.7k$（n=30 最大ケース）。
  すべて 1 回の /explore に入れる。**各プラン長 ≤ 19** で 18n 制限にも余裕。

> もっと攻めるなら：
> $|S|$ を 200 前後まで削ってもだいたい行けます（n=30, 99% 近辺）。
> 指紋衝突が心配なら $R$ を 20 に、もしくは **R を 2 種類**（$R_1, R_2$）用意し `plan(s) = s∘R1` と `s∘R2` の両方を送る（$+|S|$ 本増える代わりに一意性がさらに盤石）。

---

## 実装スケッチ（後処理）

```pseudo
alphabet = {0..5}
R = random_word(length=16)

S = all_words_of_length(3) ∪ (30 random words of length 6..9 mixed)
PLANS = []

for s in S:
  PLANS.append(s + R)          // 指紋 s
  for a in alphabet:
    PLANS.append(s + a + R)    // 指紋 s→a

// /explore へ一括送信 → results を受け取る

// 1) 指紋→room_id
fingerprint_to_id = {}
rooms = []
for s in S:
  f = result_of(s+R)           // 2bit 列
  id = fingerprint_to_id.get_or_create(f)
  rooms[id].label = f[0]       // 2bit ラベル

// 2) δ(room, a)
delta = array[numRooms][6]
for s in S:
  i = id_of(result_of(s+R))
  for a in alphabet:
    j = id_of(result_of(s+a+R))
    delta[i][a] = j

// 3) 双方向ペアリング（connections）
connections = []
for i in rooms:
  for a in alphabet:
    j = delta[i][a]
    // j 側でまだ i に割り振られていない b を取る
    b = pick_unused_b_on_j_pointing_to_i(delta)
    connections.push( (i,a) <-> (j,b) )

// startingRoom は id_of(result_of(ε+R))
```

---

## 期待される強さと限界

* **ランダム生成の迷宮**という前提（仕様に「各問題は選ぶたびにランダムに生成」と明記）なら、指紋の一意性・S の被覆は高確率で成立します。
* \*\*最悪例（同型が多い・混合が遅い）\*\*では $|S|$ を増やす／$R$ を伸ばすだけで対処できます（依然非適応・1 回呼び出しのまま）。
* **多重辺や自己ループ**も問題ありません。`δ(j,b)=i` を満たす b を全て数え上げ、双方向の**全単射**を組むだけです。観測上は入口ドア番号自体が不可視のため、同値性を壊しません。

---

## ランダムウォーク＋SAT 方式との比較

| 観点          | ランダムウォーク1本＋SAT | 固定サフィックス指紋（本提案） |   |           |   |               |
| ----------- | -------------- | --------------- | - | --------- | - | ------------- |
| /explore 回数 | 1              | 1               |   |           |   |               |
| プラン本数       | 1              | ≈ (7·           | S | )（例 1.7k） |   |               |
| 後処理         | 巨大な SAT/ILP    | 連想配列（線形）        |   |           |   |               |
| 最悪保証        | 弱い             | 弱い（ただし (        | S | ) と (     | R | ) を伸ばせば現実的に可） |
| 実装コスト       | 高              | 低               |   |           |   |               |

「/explore 本数を 1 に固定」すると、\*\*情報量は「何本のプランを詰めたか × 各プラン長」\*\*で決まります。SAT に頼らず、**観測を“指紋化”して素直に辞書引きする**のが一番コスパが良いです。

---

## 仕上げの小技

* $R$ は「完全ランダム」で十分ですが、**6 進 de Bruijn 列**や擬似乱数でも OK。衝突をさらに下げたいなら $R_1,R_2$ の二本立て。
* `S` のランダム語は**長さをばらす**（3,4,6,9あたりを混ぜる）と到達多様性が上がり、被覆が安定します。
* 後処理の健全性チェック：
  `rooms` の件数が期待 n に達しているか、`delta` が全部埋まっているか、ペアリングが完全な 6-正則無向グラフになっているかを確認。

---

必要なら、この設計に合わせた\*\*コード雛形（リクエスト生成・復元器）\*\*も書けます。まずは n=6 の小サイズで $R=12$, $|S|≈40$ で回し、指紋のユニーク性と遷移復元が一瞬で終わることを体感してみてください。
