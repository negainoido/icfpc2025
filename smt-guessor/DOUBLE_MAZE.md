# 二重の迷路を解く方法（Markdown 版）

> 僕＝ノイエンの整理メモ。実装・検証を回すための最小十分セット。口調は軽いけど中身はガチ。

---

## 🧩 概要

- **目的**: 2 重の迷路（ベース迷路 $G$ を 2 枚重ね、各辺に「同層/層スワップ」の符号が付く 2‑lift 被覆）から、**観測ログ**を用いて元の 2‑lift グラフ $\widetilde{G}$ を**同型まで復元**する。
- **戦略**: 2 段構え。

  1. **商グラフ** $G_1$（2 枚を潰した 1 枚分）を**SAT/CP‑SAT**で復元。
  2. $G_1$ 上の**オイラー路**に沿って歩きつつ、頂点に到達するたびにラベルの**下位 1bit**で**層パリティ**をマーキング。各辺の「同層(+1)/スワップ(−1)」を**一意に推定**し、2‑lift を組み立て直す。

---

## 🧱 問題モデル（簡約）

- ノードは 6 個の**ポート**（ドア）を持つ。自己ループ・多重辺ありの**無向多重グラフ**として扱う。
- 全ノードに**2bit ラベル**があり、任意タイミングで **\[v] 操作** で上書きできる（歩数に含めない）。
- **歩数上限**: ドア通過の**総ステップ**に上限（例: $\le 6N$）がある。
- 2 重化: 各辺には符号 $\sigma(e)\in\{+1,-1\}$ があり、+1 なら**同層接続**、−1 なら**層スワップ接続**。

---

## 🔑 コア発想（“踏破しながら塗る”）

- 2bit の**下位 1bit**を**層パリティ `par[u]`** 用に専用化する（上位 bit は元観測の保持や他用途）。
- **到着時**に `par[u]` をラベルの下位 bit へ即時反映（\[0]/\[1]）。書き換えは**歩数にカウントしない**。
- **木辺**（初訪問側）では `par` を**伝播**させて $\sigma=+1$ に整える。**非木辺**では到着先の下位 bit との一致/不一致から $\sigma$ を**観測**する。
- これで**1 周の踏破**だけで **順序に依存しない**エッジ符号 $\sigma$ が回収できる。

---

## 🧭 アルゴリズム

### Phase 1: 商グラフ $G_1$ 復元（SAT/CP‑SAT）

1. ランダムウォーク（複数本）で**遷移ログ**と**観測ラベル**を集める。
2. 変数:

   - `next[q][c]`：部屋 `q` のポート `c` の遷移先（自己ループ可）
   - `label[q]`：部屋ラベル（2bit）

3. 制約:

   - 6 正則（各ポートは**ちょうど 1 本**の無向辺に属する）。
   - 無向性（相互ポート対応）/自己ループ許容。
   - 観測整合（ウォークとラベルが矛盾しない）。
   - **対称性排除**（例: 部屋 0・ドア 0 周りの辞書式最小化）。

4. 解けば**商グラフ** $G_1$ が得られる（ノード集合・多重辺・自己ループ・ポート対応）。

### Phase 2: $\sigma$ 回収（オイラー路 1 周で完結）

1. $G_1$ の**オイラー路/トレイル**を **Hierholzer 法** で構成。

   - 6 正則なら**辺数 $m=3N$**、全頂点偶数で閉路あり。
   - もし実装上の都合で奇数次数が出たら、Chinese Postman 的な\*\*増補（ダブリング）\*\*で偶数化（最悪 $2m=6N$ 歩）。

2. **手順（踏破＋マーキング）**

   - 内部状態: `vis[u]∈{0,1}`, `par[u]∈{0,1}`。始点 `s` は `vis[s]=1, par[s]=0`。
   - **辺 e=uv を踏む前**：現在 `u`、これから `v` へ。
   - **到着直後**：

     - `vis[v]=0`（木辺）なら `par[v]=par[u]` に設定 → 下位 bit を `[par[v]]` で反映 → **$\sigma(e)=+1$** と記録。
     - `vis[v]=1`（非木辺）なら、到着時に見える下位 bit が `par[v]`。これが `par[u]` と**等しければ +1／異なれば −1** を記録。

   - 各辺について **$\sigma(e)$** をログ化し、**1 周で完了**。

### Phase 3: 2‑lift 再構成

- 各頂点 `u` を $u^0, u^1$ に複製（0/1 は層パリティ）。
- 辺 `uv` は

  - **$\sigma=+1$**： $u^0\!−\!v^0$, $u^1\!−\!v^1$
  - **$\sigma=−1$**： $u^0\!−\!v^1$, $u^1\!−\!v^0$

- これで $\widetilde{G}$ が同型まで一意に決まる。

---

## 🧪 正しさの要点

- **不変量**: $\sigma(e)$ は訪問順に依存しない**エッジ属性**。下位 bit で `par` を保持/再設定することで、観測が常に一貫。
- **十分性**: $G_1$ と $\sigma$ が分かれば 2‑lift は**一意再構成**できる（同型除く）。
- **歩数制約**: 基本は **$m=3N$** ステップで完了。必要なら増補でも **$\le 6N$** に収まる（書き換えは歩数に数えない）。

---

## 🛠️ 実装メモ

- **データ構造**

  - `connections`: エッジ配列（`edge_id`, `from:{room,door}`, `to:{room,door}`）。
  - `adj[u]`: `(v, edge_id, port_on_u)` の配列（多重辺/自己ループ対応）。
  - `used[edge_id]`: オイラー路での使用管理は**edge_id 単位**で。

- **オイラー路**

  - Hierholzer で**O(m)**。自己ループは次数+2、通過は 1 回。
  - 成分分断が発生するなら、Phase1 で**連結性制約**を軽く入れて防ぐ。

- **ドア列生成**

  - `edge_id` を順に辿り、**現在頂点の対応ポート**を出力。
  - 到着直後に `[bit]` を挿入し**下位 bit=par\[u]** を維持。

- **ログ**

  - 各 `edge_id` に対し `{sigma:±1, enter:u, leave:v, at:step}` を記録。
  - デバッグでは `par[u]` の変遷も出すと復旧が速い。

---

## ✅ 検証チェックリスト

1. **オイラー性**: `edges` が 0..m−1 を**一度ずつ**含む／`rooms` 長 = `len(edges)+1`。
2. **整合**: 各 i で `rooms[i] --(edge_id)--> rooms[i+1]` が `connections[edge_id]` の無向一致。
3. **次数**: ループは次数+2 で加算 → 全頂点偶数（閉路）or 奇数は 2 個（トレイル）。
4. **符号再現**: 復元した $\widetilde{G}$ を再ウォークして**元ログと一致**する。
5. **上限**: 総ステップ $\le 3N$（増補時は $\le 6N$）。書き換えはノーカウント。

---

## 🧮 参考疑似コード（Phase2 の芯）

```python
par = defaultdict(int)
vis = defaultdict(int)
par[s] = 0
vis[s] = 1
sigma = {}  # edge_id -> +1 or -1

for eid in euler_edge_order:  # Hierholzer の結果
    u = current_room()
    v = other_end(eid, u)
    walk_through(eid)          # ドア通過（1ステップ）
    if not vis[v]:             # 木辺
        par[v] = par[u]
        write_lower_bit(v, par[v])  # [0]/[1], コスト0
        vis[v] = 1
        sigma[eid] = +1
    else:                      # 非木辺
        b = read_lower_bit(v)
        sigma[eid] = (+1 if b == par[u] else -1)
        # 必要なら b を par[v] に再調整
        if b != par[v]:
            write_lower_bit(v, par[v])
```

---

## 🧷 よくある落とし穴

- **自己ループの次数+2**を忘れて奇数化 → 閉路が崩れる。
- 多重辺で**ポート使用済み**管理を頂点側だけでやる → edge_id が二重消費/未使用残り。
- `par` の再設定を**到着直後**に行わずに後回し → 観測が不整合。

---

## 🎯 まとめ

- **商グラフを先に確定**し、**踏破しながら層パリティを刻む**ことで、**1 周で $\sigma$ が取れる**。
- 出力は $G_1$ と $\sigma$。そこから 2‑lift を**機械的**に構成。歩数上限・順序依存・対称性の罠をすべて回避できる。

---

### 付録: オイラー路の長さと上限

- 辺数 $m = 3N$（6 正則・無向・自己ループは+2）。
- **素のオイラー閉路**なら**ぴったり $3N$** ステップ。増補しても\*\*$\le 6N$\*\* に収まる。
